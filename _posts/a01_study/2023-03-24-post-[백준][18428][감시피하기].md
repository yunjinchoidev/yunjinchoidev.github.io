---
title: "[백준][18428][감시피하기]"
last_modified_at: 2023-03-24T16:20:02-05:00
categories:
    - a01_study
tages:
    - ps
toc: true
toc_sticky: true
toc_label: "목차"
---

![paper.png](../../../image/ps.png)

# 해결 전략
선생님들이 학생을 발견할 수 없는 장애물을 설치할 수 있는지 없는지 여부를 확인하는 문제입니다. 선생님들의 감시 경로를 DFS 로 구현합니다. N 의 주어진 범위가 적으니 조합을 모두 구하고 각각에 대하여 DFS 를 수행하면 됩니다. 

```
생각정리
시간복잡도 -> 완전탐색으로 풀어도 되겠다.
3개의 장애물을 만든다. -> combination 을 쓰자. 36*35*34 / 3*2*1 
DFS, BFS 무관함 -> 인접리스트는 상하좌우로 모두 움직일 수 있는 거라고 생각하면 된다. 이 때 O 를 이용해 인접리스트를 제한하는 조건을 생성할 수 있다. 
Techer 인 지점에서 위에서 정의한 인접리스트를 이용했을 때 한번도 Student를 만나지 않는 경우가 있으면 성공이다. 
```

<iframe width="560" height="315" src="https://www.youtube.com/embed/9r6z5JpZDxU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>




<br>
<br>
<br>


```
import itertools
import copy

N = int(input())

map_ = [list(map(str, input().split())) for i in range(N)]

coords = [(r, c) for c in range(N) for r in range(N) if map_[r][c] == 'X']
combis = list(itertools.combinations(coords, 3))

# 북동남서
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]


def DFS(row, col, map_):

    visited = [[False for c in range(N)] for r in range(N)]
    stack = []
    stack.append((row, col))
    visited[row][col] = True

    while stack:
        r, c = stack.pop()

        # 디렉션
        for i in range(4):

            # 뎁스가 계속 들어가는 것임.
            for dep in range(1, N + 1):

                nr = r + dr[i] * dep
                nc = c + dc[i] * dep

                if nr < 0 or nr >= N or nc < 0 or nc >= N:
                    continue

                # 해당 방향에 장애물이 존재하면 해당 방향으로 더 이상 감시 불가
                if map_[nr][nc] == 'O':
                    break

                # 학생 감시 성공
                if map_[nr][nc] == 'S':
                    return False

                # 방문 표시
                if not visited[nr][nc]:
                    visited[nr][nc] = True

    return True


# 브루트 포스
for comb in combis:

    # 장애물을 설치
    copy_map_ = copy.deepcopy(map_)
    copy_map_[comb[0][0]][comb[0][1]] = 'O'
    copy_map_[comb[1][0]][comb[1][1]] = 'O'
    copy_map_[comb[2][0]][comb[2][1]] = 'O'

    answer = 'YES'

    # 맵 내의 모든 선생님들이 감시할 수 있는 범위를 DFS 를 통해 조사.
    for r in range(N):
        for c in range(N):
            if copy_map_[r][c] == 'T':
                if not DFS(r, c, copy_map_):
                    answer = 'NO'
        if answer == 'NO':
            break

    # 어떤 장애물의 조합이 모든 선생님들이 단 한번도 감시를 성공하지 못한 경우가 발생한 경우.
    if answer == 'YES':
        break

print(answer)

```