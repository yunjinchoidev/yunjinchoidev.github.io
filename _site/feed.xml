<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-08T11:41:39+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Reinvent love! - Democratization of Love</title><subtitle>NLP 쪼렙입니다.</subtitle><author><name>최윤진</name></author><entry><title type="html">Post: ai tech -Day03</title><link href="http://localhost:4000/aitech/post-day03/" rel="alternate" type="text/html" title="Post: ai tech -Day03" /><published>2023-03-08T00:00:00+09:00</published><updated>2023-03-08T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-day03</id><content type="html" xml:base="http://localhost:4000/aitech/post-day03/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>

<h1 id="d">d</h1>

<h1 id="d-1">d</h1>

<h1 id="dd">dd</h1>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: Python 정리</title><link href="http://localhost:4000/aitech/post-python/" rel="alternate" type="text/html" title="Post: Python 정리" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-08T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-python</id><content type="html" xml:base="http://localhost:4000/aitech/post-python/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>

<p>::: {.cell .markdown collapsed=”false”}</p>
<h1 id="파이썬-강의-노트">[파이썬] 강의 노트</h1>

<h1 id="목차">[목차]</h1>

<blockquote>
  <h3 id="개요">개요</h3>

  <h3 id="기초-문법">기초 문법</h3>

  <h3 id="객체-지향">객체 지향</h3>

  <h3 id="파이썬으로-데이터-다루기">파이썬으로 데이터 다루기</h3>

  <h3 id="numpy">Numpy</h3>

  <h3 id="pandas">Pandas</h3>
</blockquote>

<hr />

<h1 id="개요-1">개요</h1>

<ul>
  <li>운영체제
    <ul>
      <li>윈도우, 맥, 리눅스</li>
    </ul>
  </li>
  <li>파일시스템
    <ul>
      <li>root 디렉토리에서 시작하는 트리 구조</li>
      <li>디렉토리, 파일</li>
      <li>절대경로, 상대경로</li>
      <li></li>
    </ul>
  </li>
  <li>터미널
    <ul>
      <li>CLI</li>
    </ul>
  </li>
  <li>파이썬
    <ul>
      <li>플랫폼 독립적</li>
      <li>인터프리터 언어</li>
      <li>객체 지향</li>
      <li>동적 타이핑 언어</li>
    </ul>
  </li>
  <li>컴파일러 VS 인터프리터
    <ul>
      <li>컴파일러</li>
      <li>인터프리터</li>
    </ul>
  </li>
  <li>Why Python ?
    <ul>
      <li>Life is too short, You need Python</li>
    </ul>
  </li>
  <li>실행환경
    <ul>
      <li>주피터 노트북</li>
      <li>코랩</li>
      <li>Visual Studio Code
:::</li>
    </ul>
  </li>
</ul>

<p>::: {.cell .markdown collapsed=”false”}</p>
<h1 id="기초-문법">기초 문법</h1>

<ul>
  <li>Variable
    <ul>
      <li>변수는 메모리 주소를 가지고 있고</li>
      <li>변수에 들어가는 값은 메모리 주소에 할당된다.</li>
      <li>패킹, 언패킹
        <ul>
          <li>t = [1, 2, 3]</li>
          <li>a, b, c = t</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Function and Console I/O
    <ul>
      <li>함수적 개념이 대단히 중요하다.</li>
      <li>Function
        <ul>
          <li>어떤 일을 수행하는 코드의 덩어리
:::</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>::: {.cell .markdown collapsed=”false”}
:::</p>

<p>::: {.cell .code execution_count=”4” collapsed=”false”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 함수 예시
</span><span class="k">def</span> <span class="nf">cal_rec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="n">area</span> <span class="o">=</span> <span class="n">cal_rec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    2
:::
:::</p>

<p>::: {.cell .code execution_count=”5” collapsed=”false”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력 받기 Console I/O
</span><span class="n">x</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    10
:::
:::</p>

<p>::: {.cell .code execution_count=”19” collapsed=”false”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 포맷에 따른 출력
</span>
<span class="c1"># (1) % string
</span><span class="k">print</span><span class="p">(</span><span class="s">'%s %s'</span> <span class="o">%</span> <span class="p">(</span><span class="s">'x'</span><span class="p">,</span> <span class="s">'u'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'{} {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">'x'</span><span class="p">,</span> <span class="s">'y'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'%d %d'</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'{} {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1"># (2) format
</span><span class="k">print</span><span class="p">(</span><span class="s">"I eat %d appe %s"</span> <span class="o">%</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">'G'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"product %10s"</span> <span class="o">%</span> <span class="s">"GGG"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"gogo {0} {1} {2}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="c1"># (3) fstring
# 가장 많이 쓴다.
</span><span class="n">name</span> <span class="o">=</span> <span class="s">"yunjin"</span>
<span class="n">age</span> <span class="o">=</span> <span class="mi">1111</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="o">*&gt;</span><span class="mi">20</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>




<span class="c1"># padding 방법 참고
</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    x u
    x y
    1 2
    1 2
    I eat 3 appe G
    product        GGG
    gogo 1 2 3
    Hello, <strong>**</strong><strong>**</strong>**yunjin 1111
:::
:::</p>

<p>::: {.cell .markdown collapsed=”false”}</p>
<ul>
  <li>Conditionals &amp; Loops
    <ul>
      <li>조건문과 반복문
        <ul>
          <li>if, for</li>
        </ul>
      </li>
      <li>논리적인 생각의 기본</li>
    </ul>
  </li>
  <li>String &amp; advanced function concept
    <ul>
      <li>데이터 타입은 메모리의 효율적 활용을 위해 매우 중요합니다.</li>
    </ul>
  </li>
  <li>Call By Value || Call By Reference
    <ul>
      <li>Call By Value
        <ul>
          <li>값을 넘김</li>
        </ul>
      </li>
      <li>Call By Reference
        <ul>
          <li>메모리 주소를 넘김</li>
          <li>포인터 개념</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>파이썬은 call by Object References
:::</li>
</ul>

<p>::: {.cell .code execution_count=”1” collapsed=”false”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="n">eggs</span><span class="p">):</span>
    <span class="n">eggs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">eggs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">eggs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">eggs</span><span class="p">)</span>

<span class="n">ham</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">spam</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    [2, 3]
    [0, 1, 5]
:::
:::</p>

<p>::: {.cell .markdown collapsed=”false”}</p>
<ul>
  <li>Scoping Rule
    <ul>
      <li>지역 변수 local variable</li>
      <li>전역 변수 Global variable</li>
    </ul>
  </li>
  <li>재귀 함수
    <ul>
      <li>재귀 함수를 잘 활용해야 진정한 고수다!</li>
    </ul>
  </li>
  <li>functino type hints
    <ul>
      <li>리턴 타입을 알 기 쉽게 해주는 것</li>
      <li>안전성 보장</li>
    </ul>
  </li>
  <li>docstring
    <ul>
      <li>함수의 스펙을 사전에 작성하는 것</li>
    </ul>
  </li>
  <li>코드는 하나의 보고서다.
    <ul>
      <li>잘 해야지 !</li>
      <li>코딩 컨벤션을 잘 지키자. (구글 컨벤션)</li>
      <li>일관성을 지켜야지.</li>
      <li><a href="https://yosseulsin-job.github.io/Google-Python-Style-Guide-kor/">링크</a></li>
      <li>conda install -c anaconda flake8
        <ul>
          <li>이걸로 체크하라.</li>
        </ul>
      </li>
      <li>conda install black
        <ul>
          <li>이것은 수정해줌 (표준임)
:::</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>::: {.cell .code execution_count=”1” collapsed=”false”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="s">"""_summary_
    이것이 docstring 다.

    Args:
        name (str): _description_

    Returns:
        str: _description_
    """</span>    
    <span class="k">return</span> <span class="sa">f</span><span class="s">"GGG </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>
<span class="n">gg</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="s">"qq"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    GGG qq
:::
:::</p>

<p>::: {.cell .markdown}</p>
<h2 id="python-data-structure">Python Data Structure</h2>

<ul>
  <li>stack
    <ul>
      <li>LIFO</li>
    </ul>
  </li>
  <li>queue
    <ul>
      <li>FIFO</li>
    </ul>
  </li>
  <li>tuple, set</li>
  <li>dictionary</li>
  <li>Collection
:::</li>
</ul>

<p>::: {.cell .markdown}</p>
<h1 id="pythonic-code">Pythonic code</h1>

<ul>
  <li>파이썬 다운 스타일
    <ul>
      <li>많은 딥러닝 논문, 엔지니어가 파이쏘닉 코드를 쓰고 있기 때문에
인지하고 있어야 한다.</li>
    </ul>
  </li>
  <li>split, join</li>
  <li>list comprehension</li>
  <li>enumerate, zip</li>
  <li>lambda</li>
  <li>map</li>
  <li>reduce
    <ul>
      <li>대용량의 데이터를 다룰 때</li>
      <li>리스트에 특정 람다함수를 지속적으로 적용시켜줄 때</li>
    </ul>
  </li>
  <li>generator (주의 !! )
    <ul>
      <li>실제로 값을 안 들어놓고 실제 호출했을 때 호출</li>
      <li>메모리를 절약할 수 있음.</li>
      <li>파일 데이터, 큰 데이터를 처리할 때 사용 하면 된다.</li>
    </ul>
  </li>
  <li>asterisk</li>
  <li>fucntion parameter
    <ul>
      <li>keyword arguments</li>
      <li>Default arguments</li>
      <li>variable arguments
        <ul>
          <li>
            <p>asterist = * 기호</p>
          </li>
          <li>
            <ul>
              <li></li>
            </ul>
          </li>
          <li>
            <p>딕트만 받기 -&gt; **</p>
          </li>
          <li>unpacking
:::</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>::: {.cell .code execution_count=”9”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="n">result2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s">'to'</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="s">'one'</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>

<span class="c1">#zip
</span><span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="s">'go'</span><span class="p">,</span> <span class="s">'ho'</span><span class="p">,</span> <span class="s">'no'</span><span class="p">]</span>
<span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="s">'ba'</span><span class="p">,</span> <span class="s">'qa'</span><span class="p">,</span> <span class="s">'to'</span><span class="p">]</span>
<span class="n">uu</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="n">uu</span><span class="p">)</span>

<span class="c1"># reduce
</span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>


<span class="c1"># asterisk
</span><span class="k">def</span> <span class="nf">asterisk_test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">asterisk_test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">45</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">asterisk_test2</span><span class="p">(</span><span class="o">**</span><span class="n">kwards</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">kwards</span><span class="p">)</span>

<span class="n">asterisk_test2</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">'gg'</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'ggg'</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .stream .stdout}
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [‘to’, ‘tn’, ‘te’, ‘oo’, ‘on’, ‘oe’]
    [[‘go’, ‘ba’], [‘ho’, ‘qa’], [‘no’, ‘to’]]
    51
    {‘a’: 3, ‘b’: ‘gg’, ‘c’: ‘ggg’}
:::
:::</p>

<p>::: {.cell .markdown}</p>
<h1 id="객체-지향">객체 지향</h1>

<ul>
  <li>
    <p>Object-Oriented Programming</p>
  </li>
  <li>
    <p>객체</p>

    <ul>
      <li>속성 <code class="language-plaintext highlighter-rouge">Variable</code></li>
      <li>행동 <code class="language-plaintext highlighter-rouge">Method</code></li>
    </ul>
  </li>
  <li>
    <p><strong>init</strong> : 초기화 함수</p>
  </li>
  <li>
    <p>매직 메서드 <a href="https://tibetsandfox.tistory.com/42">링크</a></p>
  </li>
  <li>
    <p>실전 클래스를 만들어서 연습해보라.</p>
  </li>
  <li>
    <p>상속 (Inheritance)</p>

    <ul>
      <li>super() 부모 객체 불러오기</li>
    </ul>
  </li>
  <li>
    <p>다형성 (Polymorphism)</p>

    <ul>
      <li>내부로직을 다르게 구현하기..</li>
      <li><code class="language-plaintext highlighter-rouge">NotImplementedError()</code></li>
    </ul>
  </li>
  <li>
    <p>가시성 (Visibility)</p>

    <ul>
      <li>심판이 축구 선수의 가족을 알아야 합니까?</li>
      <li>인터페이스만 알아서 쓰시라.</li>
      <li>private 변수로 선언해서 타객체가 접근하지 못하도록 합니다.</li>
      <li>데코레이터 : \@property</li>
    </ul>
  </li>
  <li>
    <p>일급객체 (first-class object)</p>

    <ul>
      <li>변수나 데이터 구조에 할당이 가능한 객체</li>
      <li>파이썬 함수는 일급함수.</li>
    </ul>
  </li>
  <li>
    <p>inner function</p>

    <ul>
      <li>closures : inner function 을 return 을 반환</li>
    </ul>
  </li>
  <li>
    <p>decorator</p>

    <ul>
      <li>함수를 어노테이션으로 써버리는 것.
:::</li>
    </ul>
  </li>
</ul>

<p>::: {.cell .markdown}</p>
<h1 id="모듈">모듈</h1>

<ul>
  <li>남이 만든 것을 가져다 쓰기 By Module</li>
  <li>조각을 모아 프로그램을 만든다.</li>
</ul>

<h1 id="가상환경">가상환경</h1>

<ul>
  <li>pip</li>
  <li>conda
    <ul>
      <li>conda install ~</li>
      <li>conda create -n ''</li>
      <li>conda activate ~~</li>
    </ul>
  </li>
</ul>

<h1 id="오픈소스">오픈소스</h1>

<ul>
  <li>matplotlib</li>
  <li>tqdm
:::</li>
</ul>

<p>::: {.cell .code execution_count=”2”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'some numbers'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># 반복문에서 실행 바를 보여주기 
</span><span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>::: {.output .display_data}
<img src="vertopal_1fb2eb6261c4413e91a100c67cd2e458/4babb087123953cd4985ad474581b3954675c63e.png" alt="" />
:::
:::</p>

<p>::: {.cell .markdown}</p>
<h1 id="데이터-다루기">데이터 다루기</h1>

<h2 id="exception">Exception</h2>

<ul>
  <li>예외처리를 잘 하면 프로그램은 안전하게 실행할 수 있다.</li>
  <li>전체 익셉션을 잡으면 추적이 어렵다. (좋은 코드가 아니다.)</li>
  <li>try, except, finally</li>
  <li></li>
</ul>

<h2 id="file">File</h2>

<ul>
  <li>Binary 파일</li>
  <li>Text 파일</li>
  <li><code class="language-plaintext highlighter-rouge">open</code> 키워드를 사용해서 파일 읽는다.
    <ul>
      <li>r : 읽기</li>
      <li>w : 쓰기</li>
      <li>a : 추가</li>
    </ul>
  </li>
</ul>

<h2 id="log-handling">Log Handling</h2>
<p>:::</p>

<p>::: {.cell .code execution_count=”12”}</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span>
<span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
<span class="n">f</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">my_file</span><span class="p">:</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">my_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cc</span><span class="p">),</span> <span class="n">cc</span><span class="p">)</span>

<span class="n">ff</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"gogo.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf8"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="s">"GG"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span>
    <span class="n">ff</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">ff</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

</code></pre></div></div>

<p>::: {.output .stream .stdout}
    ddddfasdfa
    &lt;class ‘str’&gt; ddddfasdfa
:::
:::</p>

<p>::: {.cell .markdown}
Picle</p>

<ul>
  <li>객체를 임시로 저장</li>
  <li>딥러닝에서 사용 되는 원리 (미분값보관)</li>
</ul>

<h2 id="loggin-handle">Loggin Handle</h2>

<ul>
  <li>로깅 데이터를 추적하는 것은 굉장한 이슈
    <ul>
      <li>딥러닝 학습 중 필요한 로깅을 슬랙, 카카오톡, 라인으로 발송
해준다.</li>
    </ul>
  </li>
  <li>게임에서 핵을 어떻게 잡는가 ?</li>
  <li>import logging</li>
  <li>loggging.debug</li>
  <li>loggging.warn</li>
  <li>debug &gt; INFO &gt; warnning &gt; error &gt; critical</li>
  <li>logger.setLevel(loggin.INFO)</li>
  <li>&lt;&gt; (야믈을 쓸꺼냐, cli를 쓸꺼냐.)
    <ul>
      <li>cofigparser</li>
      <li>argpaser
        <ul>
          <li>command line option
:::</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>::: {.cell .markdown}
:::</p>

<p>::: {.cell .markdown}</p>
<h1 id="데이터-타입-csv-웹-xml-json">데이터 타입 (CSV, 웹, XML, JSON)</h1>

<hr />

<h3 id="csv">CSV</h3>

<h3 id="웹">웹</h3>

<h3 id="xml">XML</h3>

<h3 id="json">JSON</h3>

<hr />

<h3 id="정규식">정규식</h3>

<ul>
  <li>복잡한 문자열 패턴을 정의하는 문자 표현 공식</li>
  <li>파이썬
    <ul>
      <li>import re</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-beautifulsoup--beautifulsoup">### beautifulsoup {#-beautifulsoup}</h2>
<p>:::</p>

<p>::: {.cell .markdown}</p>
<h1 id="numpy">Numpy</h1>

<ul>
  <li>dl 에 있어서 가장 기본적인 모듈. 아주 잘 다뤄야 한다.</li>
  <li>선형대수학</li>
  <li>행렬과 텐서를 어떻게 넘파이로 표현할 것인가?</li>
  <li>import numpy as np</li>
  <li>conda install numpy</li>
  <li>numpy 는 c 로 구현 되어 있어서 성능 이점</li>
  <li>ndarray
    <ul>
      <li>np.array([1,2,3,4], float)</li>
    </ul>
  </li>
  <li>rank
    <ul>
      <li>scalar</li>
      <li>vector</li>
      <li>matrix</li>
      <li>3-tensor</li>
      <li>n-tensor</li>
    </ul>
  </li>
  <li>np.reshape(m,n)
    <ul>
      <li>np.reshape(-1,m)</li>
    </ul>
  </li>
  <li>np.flatten()</li>
  <li>np.arrang(n, m, t)</li>
  <li>np.zeros</li>
  <li>np.ones()</li>
  <li>np.empty()
    <ul>
      <li>does'nt memory initialization</li>
    </ul>
  </li>
  <li>np.ones_like()</li>
  <li>np.identity(n=3)</li>
  <li>np.diag()</li>
  <li>np.random.uniform()</li>
  <li>test_array.sum(axis=n)</li>
  <li>test_array.std(axis=n)</li>
  <li>test_array.mean(axis=n)</li>
  <li>np.vstack()</li>
  <li>np.hstack()</li>
  <li>test_array.dot(test_array2)</li>
  <li>test_array.T</li>
  <li>test_array.transpose()</li>
  <li>broadcasting</li>
  <li>np.where</li>
  <li>np.all</li>
  <li>np.any</li>
  <li>np.argmax</li>
  <li>np.argmin</li>
  <li>boolean index</li>
  <li>fancy index</li>
  <li>loadtxt &amp; savetxt
    <ul>
      <li>np.loadtxt</li>
      <li>np.savetxt</li>
    </ul>
  </li>
</ul>

<h2 id="참고">참고</h2>

<ul>
  <li>%timeit 를 앞에 붙이면 시간 계산 해줌
    <ul>
      <li>numpy &gt; list comporehension &gt; loop</li>
      <li>넘파이의 성능 이점
:::</li>
    </ul>
  </li>
</ul>

<p>::: {.cell .markdown}</p>
<h1 id="pandas">Pandas</h1>

<ul>
  <li>구조화된 데이터 처리 도구</li>
  <li>conda install pandas</li>
  <li>import pandas as np</li>
  <li>pd.read_csv</li>
  <li>DataFrame, Series</li>
  <li>df.head()</li>
  <li>df.head().T</li>
  <li>conda install --y -c anaconda xlrd</li>
  <li>df.loc</li>
  <li>df.iloc</li>
  <li>df.index</li>
  <li>df.reset_index</li>
  <li>df.drop(1, inplace=True)</li>
  <li>df.add(x, fill_value=0)</li>
  <li>lambda</li>
  <li>map</li>
  <li>apply</li>
  <li>df.describe()</li>
  <li>df.unique</li>
  <li>df.sum(axis=1)</li>
  <li>df.corr</li>
  <li>df.innull()</li>
</ul>

<h2 id="pandas-연산">Pandas 연산</h2>

<ul>
  <li>groupby</li>
  <li>groupby - transform
    <ul>
      <li>그룹별로 특정 연산 (Ex. 정규화)</li>
    </ul>
  </li>
  <li>groupby - filter</li>
  <li>pivot_table</li>
  <li>joint method
    <ul>
      <li>merge</li>
    </ul>
  </li>
  <li>database connection
    <ul>
      <li>db 연결</li>
      <li>import sqlite3</li>
    </ul>
  </li>
  <li>xls persistence
    <ul>
      <li>엑셀을 피클형태로 하는걸 추천</li>
    </ul>
  </li>
</ul>

<h2 id="참고">참고</h2>

<ul>
  <li>가장 좋은 것은 배운 수학/통계적 지식을 실제 데이터에 적용해보는 것.</li>
</ul>

<h2 id="추천">추천</h2>

<ul>
  <li>판다스로 실제 데이터를 다루는 연습을 하시라.</li>
  <li>캐글 하자 ~
:::</li>
</ul>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: Pytorch</title><link href="http://localhost:4000/aitech/post-pytorch/" rel="alternate" type="text/html" title="Post: Pytorch" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-08T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-pytorch</id><content type="html" xml:base="http://localhost:4000/aitech/post-pytorch/"><![CDATA[<hr />
<h1 id="1--introduction-to-pytorch">1.  Introduction to PyTorch</h1>
<p>밑바닥부터 딥러닝 코드 짜기를 짤 수도 있습니다. <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=256067157&amp;start=slayer">책</a>
하지만 저희는 딥러닝 프레임워크를 사용합니다. 예를 들어서 텐서플로와 파이토치가 있습니다. 텐서플로는 구글에서 만들었고, 파이토치는 페이스북에서 만들었습니다.</p>

<p>저희는 파이토치를 사용할 것입니다. 파이토치는 장점이 꽤 많습니다. 대표적으로 Define by Run 이라는 작동 방식인데요. 이것은 실행을 한면서 계산 그래프(Computational Graph)를 생성하는 것을 말합니다. 반면 텐서플로는 Define by Run 이라고 해서 그래프를 먼저 정의하는 방식입니다. 파이토치는 학회, 논문에 강점을 가지고 있으며 텐서플로는 실무(프로덕션)에 강점을 가지고 있다고 할 수 있죠. 그리고 파이토치는 즉시 딥러닝 코드가 작동하는지 확인을 할 수가 있으며 numpy, autograd, function 의 기능을 모두 제공합니다.</p>

<h1 id="2-dive-to-pytorch">2. Dive To Pytorch</h1>
<p>이제 파이토치 기본에 대해서 공부해 봅시다. 
먼저 autugrad 에 대해서 공부해봅시다. 
아래 코드는 파이토치를 통해 오차 역전파를 계산하는 식입니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>w = torch.tensor(2.0, requires_grad=True)
y = w**2
z = 10*y + 25
z.backward()
w.grad

&gt; z.backward() 를 통해 오차역전파를 계산
&gt; w.grad 를 통해 z 에 대한 w 그레디언트 추출
</code></pre></div></div>

<h2 id="여기서-잠깐-">여기서 잠깐 !</h2>
<blockquote>
  <p>최대가능도 추정법이란 뭘까요? 관찰된 데이터가 어떠한 모수로부터 나왔을 가능성이 가장 높은지를 추정하는 방법입니다. 모수란 무엇일까요? 모수는 모집단의 특성(모평균,모분산 등..)을 나타내는 값으로, 이 값을 모집단을 전수조사해야만 알수있는 값입니다. 실질적으로 모집단의 크기와 범위가 너무 방대하기에 전수조사를 실시하지 않고 표본조사를 하는데 표본평균,표본분산 등으로 모평균, 모분산등을 추정할수가 있다.</p>
</blockquote>

<h1 id="3-템플릿을-사용합시다">3. 템플릿을 사용합시다.</h1>
<p>여러분은 언제까지 코랩을 쓰실 생각입니까? 템플릿을 씁시다. 고수가 되는 지름길이죠. 템플릿을 사용함으로써 우리는 많은 강점을 가져갈 수 있습니다. <code class="language-plaintext highlighter-rouge">실행, 데이터, 모델,  설정, 로깅, 지표, 유틸리티</code> 이 대표적이죠.</p>

<p>다음 오픈 소스에서 파이토치 템플릿을 다운 받고 면밀하게 분석해보십시요. 면밀하게 분석을 해봅시다. <a href="https://github.com/victoresque/pytorch-template">링크</a></p>

<h1 id="4-autograd--optimizer">4. AutoGrad &amp; Optimizer</h1>
<p>논문을 한 번 구현해봅시다. 딥러닝이란 layer를 쌓고 레고 블럭을 쌓는 일련의 과정이라고 할 수 있습니다. input</p>
<ul>
  <li>딥러닝 -&gt; layer 쌓기 -&gt; 레고 블럭 쌓기</li>
  <li>4요소
    <ul>
      <li>input</li>
      <li>output</li>
      <li>forward</li>
      <li>backward</li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="5-dataset--dataloader">5. Dataset &amp; Dataloader</h1>
<p>모델도 중요하지만, 데이터를 어떻게 잘 다루느냐도 중요합니다. 엄청나게 많은 데이터가 있습니다. 이것을 어찌해야 할까요? 우리에겐 파이토치가 있습니다.</p>
<ul>
  <li><strong>Pytorch Dataset</strong>
    <ul>
      <li>먼저 데이터를 텐서로 바꾸고 DataLoder 로 모델에 먹이기</li>
    </ul>
  </li>
  <li><strong>CustomDataset</strong>
    <ul>
      <li>CustomDataset을 정의 하기 위해서 3개의 메소드를 반드시 정의해야 한다.
        <ul>
          <li>init, len, getitem</li>
          <li>utils.data.Dataset 상속</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DataLoder
    <ul>
      <li>CustomDataset, 기타 옵션으로 실제 데이터에 적용하면 된다.</li>
      <li>옵션
        <ul>
          <li>미니배치 사이즈</li>
          <li>… 많다.</li>
        </ul>
      </li>
      <li>코드를 뜯어보시라.</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="6-모델-불러오기">6. 모델 불러오기</h1>
<ul>
  <li>상황
    <ul>
      <li>이 말인 즉슨 우리는 실제 라벨과 예측 라벨의 오차 함수의 그레디언트를 계산하고 오차역전파를 계산하여 W 가중치 텐서를 업데이트 시켰다. (공부를 했다. 경험을 했다. 수련을 했다.)</li>
      <li>우리는 이 결과를 전달하려 한다.</li>
    </ul>
  </li>
  <li>model.save()</li>
  <li>저장법 2가지
    <ul>
      <li>파라메터만 저장</li>
      <li>모델형테 + 파라메터 저장</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="7-monitoring-tools-for-pytorch">7. Monitoring tools for PyTorch</h1>
<ul>
  <li>체크포인트
    <ul>
      <li>학습의 중간 결과를 저장</li>
      <li>earlystopping</li>
      <li>loss, metric</li>
      <li>Earlystopping : 조기 종료</li>
    </ul>
  </li>
  <li>Loggin
    <ul>
      <li>Logging이란, 학습이 진행되면서 주요하다고 생각되는 지표들이나 학습의 상태 등 관련된 정보들을 기록하는 것</li>
    </ul>
  </li>
  <li>Tensorboard</li>
  <li>
    <p>Tensorboard는 TensorFlow의 프로젝트로 만들어진 시각화 도구로 학습 그래프, Metric, 학습 결과의 시각화를 지원</p>
  </li>
  <li>Weight, Biases
    <ul>
      <li>
        <h2 id="머신러닝-실험을-원활하게-지원하기-위한-상용-도구로써-협업-code-versioning-실험-결과-기록-등의-기능을-제공하는-시각화-툴">머신러닝 실험을 원활하게 지원하기 위한 상용 도구로써, 협업, code versioning, 실험 결과 기록 등의 기능을 제공하는 시각화 툴</h2>
        <h1 id="8-muti-gpu">8. Muti-GPU</h1>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="9-hyperparameter-tuning">9. Hyperparameter Tuning</h1>
<ul>
  <li>학습률(Learning rate)</li>
  <li>최적화 함수(Optimizer)</li>
  <li>손실 함수(Loss Fucnction)</li>
  <li></li>
</ul>

<hr />

<h1 id="10-pytorch-troubleshooting">10. PyTorch Troubleshooting</h1>

<hr />

<hr />
<h1 id="생각해볼점">생각해볼점</h1>
<ul>
  <li>AutoGrad 작동 방식 ?</li>
  <li></li>
</ul>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[1. Introduction to PyTorch 밑바닥부터 딥러닝 코드 짜기를 짤 수도 있습니다. 책 하지만 저희는 딥러닝 프레임워크를 사용합니다. 예를 들어서 텐서플로와 파이토치가 있습니다. 텐서플로는 구글에서 만들었고, 파이토치는 페이스북에서 만들었습니다.]]></summary></entry><entry><title type="html">Post: 딥러닝에 필요한 math 정리</title><link href="http://localhost:4000/aitech/post-aimath/" rel="alternate" type="text/html" title="Post: 딥러닝에 필요한 math 정리" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-08T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-aimath</id><content type="html" xml:base="http://localhost:4000/aitech/post-aimath/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>

<ul>
  <li>
    <h1><벡터></벡터></h1>
  </li>
</ul>

<hr />
<ul>
  <li>
    <h1 id="-1"><행렬></행렬></h1>
    <ul>
      <li>행렬곱
        <ul>
          <li>행과 열의 조건을 맞춰야 연산가능함.</li>
        </ul>
      </li>
      <li>역행렬
        <ul>
          <li>곱의 연산을 했을 때 항등행렬이 나온다.</li>
        </ul>
      </li>
      <li>유사 역행렬
        <ul>
          <li>무어펜로스(Moore-Penrose) 역행렬
            <ul>
              <li><img src="무어펜로즈.png" alt="무어펜로즈.png" /></li>
              <li><code class="language-plaintext highlighter-rouge">np.linalg.pinv</code></li>
              <li>행과 열의 크기에 따라 순서가 달라지니 유의 할 것.</li>
            </ul>
          </li>
          <li>연립방정식, 선형회귀 분석에 응용됨.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">생각</code>
        <ul>
          <li>왜 행렬을 배우는가? 차원이동, 연산</li>
        </ul>
      </li>
      <li>문제
        <ul>
          <li>사이킷런의 선형회귀 모델과 무어펜로즈의 선형회귀를 직접 구현해보시오.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="딥러닝을-제대로-이해하기-위해선-선형대수학을-수준-높게-학습해야-한다">딥러닝을 제대로 이해하기 위해선 ‘선형대수학’을 수준 높게 학습해야 한다</h4>

<hr />
<h1 id="-2"><경사하강법></경사하강법></h1>
<ul>
  <li>미분
    <ul>
      <li>접선의 기울기</li>
      <li>sysmpy.diff -&gt; 미분계산 가능</li>
      <li>**<어느 차원에서든="">** 그 점에서 증가하는가, 감소하는가를 알 수 있다.</어느></li>
      <li>어느 차원으로 확장한다는 것은 변수를 스칼라가 아닌 벡터를 사용한다는 것.</li>
    </ul>
  </li>
  <li>경사하강법
    <ul>
      <li>감소하는 방향으로 쭈욱 가다 <strong>보면</strong> 언젠가 평지를(극소값)을 만날 것이야 =&gt; 경사하강법</li>
      <li>컴퓨터에서 미분값이 0 인 곳을 찾기란 쉽지 않으므로 아주 작은 값(오메가) 보다 더 미분 값이 작으면 종료하면 되시것다.</li>
      <li>학습률 -&gt; 얼마나 큰 보폭으로 갈것인가? (하이퍼 파라메터)</li>
      <li>모든 데이터 사용
        <ul>
          <li>성능이 확률적 경사 하강법에 비해 좋지 않고, 하드웨어에 부담이 간다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>변수가 벡터인경우엔
    <ul>
      <li>편미분을 사용한다.</li>
    </ul>
  </li>
  <li>그레디언트 벡터
    <ul>
      <li>벡터의 변수 별로 편미분을 계산한 함수</li>
      <li><img src="gradient.png" alt="gradient.png" /></li>
      <li>그레디언트 벡터에 - 를 붙여서 이동하게 되면 <strong>가장 빨리</strong> 극소값을 향해 가게 된다.</li>
      <li>그레디언트 벡터의 <code class="language-plaintext highlighter-rouge">norm</code> 값을 구해서 일정 값보다 작게 되면 학습을 종료하는 방식으로 극소값을 찾으면 된다. (계속 내려가다가 더 이상 변화가 없는 것 같아. -&gt; 일단 멈춰!)
        <h1 id="선형회귀-모델에서-경사하강법-적용해보기">선형회귀 모델에서 경사하강법 적용해보기</h1>
      </li>
    </ul>
  </li>
  <li>위에서 무어 펜로즈 행렬을 통해서 선형 모델을 어떻게 찾아야 할 지 알았다.</li>
  <li>우리가 해야 할것은 무어펜로즈 행렬을 곱해서 나온 우변 식을 경사하강법을 하지 않고 !! 오직 경사 하강법을 적용시켜 극소값이 되는 지점을 찾는 것이다.</li>
  <li>
    <h5 id="this-is-funny-">this is funny !</h5>
    <ul>
      <li>직접 계산해보자.</li>
    </ul>
  </li>
  <li>학습률과 학습횟수를 적절하게 선택했을 때만 수렴을 보장할 수 있다.</li>
  <li>비선형회귀의 경우, 볼록하지 않기 때문에 수렴을 보장할 수 없다.</li>
</ul>

<h1 id="확률적-경사하강법">확률적 경사하강법</h1>
<ul>
  <li>데이터를 일부 사용해서 경사하강법을 적용하는 것.</li>
  <li>데이터 하나만 사용</li>
</ul>

<h1 id="미니배치-확률-경사하강법-일반적">미니배치 확률 경사하강법 (일반적)</h1>
<ul>
  <li>데이터 여러개 사용</li>
  <li>SGD 가 경사하강법보다 낫다는 것이 실증적으로 검증되었다.</li>
  <li>데이터를 일부로 사용하기 때문에 목적식이 매번 달라짐.</li>
  <li>학습률, 미니배치사이즈 고려해야 함.</li>
</ul>

<hr />
<h1 id="5-딥러닝-학습방법">5. 딥러닝 학습방법</h1>
<ul>
  <li>이제 비선형모델인 신경망을 도전해보자.</li>
  <li>소프트맥스
    <ul>
      <li>모델의 출력을 확률로 해석 =&gt; 확률 벡터로 변환
        <ul>
          <li>가장 큰 값이 예측값이 되는 것임.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>신경망은 <strong>선형모델과 활성함수를 합성한 함수</strong>다. [MLP]
    <ul>
      <li>잠재벡터들의 누적 공간에 활성화 함수를 적용한다.</li>
    </ul>
  </li>
  <li>활성함수
    <ul>
      <li>R 위에 정의된 비선형 함수</li>
      <li>활성함수를 쓰지 않으면 딥러닝은 선형모형과 차이가 없다.</li>
      <li>ex) Relu, tanh, sigmoid</li>
    </ul>
  </li>
  <li>순전파
    <ul>
      <li>주어진 신경망 계산을 하는 것</li>
    </ul>
  </li>
  <li>왜 층을 여러개 쌓는가?
    <ul>
      <li>수학적으로 임의의 연속함수를 근사할 수 있다는 것이 증명되어 있다.</li>
      <li>‘세계’를 표현할 수 있다.</li>
    </ul>
  </li>
  <li>역전파
    <ul>
      <li>경사하강법을 이용해서 가중치를 업데이트 하는 것.</li>
      <li>위층부터 저층으로 그레디어트 벡터를 전달해야 함(연쇄법칙)</li>
      <li>메모리에 저장해서 사용해야 함.</li>
      <li>tensorflow, pytorch 에는 자동 구현되어 있음.</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="6-확률론">6. 확률론</h1>
<ul>
  <li>딥러닝은 확률론 기반의 기계학습 이론에 바탕을 두고 있다.
    <ul>
      <li>확률론이 중요한 이유</li>
      <li>사례
        <ul>
          <li>분류 문제
            <ul>
              <li>예측 오차의 분산을 최소화</li>
            </ul>
          </li>
          <li>교차 엔트로피 문제
            <ul>
              <li>모델 예측의 불확실성을 최소화</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>확률 분포는 데이터의 초상화</li>
  <li>확률은 면적이다.</li>
  <li>확률변수
    <ul>
      <li>이산 확률 변수
        <ul>
          <li>이산 확률을 급수(시그마)</li>
        </ul>
      </li>
      <li>연속 확률 변수
        <ul>
          <li>연속 확률을 적분</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>목표
    <ul>
      <li>데이터의(표본) 확률 분포를 가지고 -&gt; 실제 (모집단)의 확률 분포를 추정한다.</li>
    </ul>
  </li>
  <li>주변확률분포</li>
  <li>통계값(모수)
    <ul>
      <li>기댓값</li>
      <li>분산</li>
      <li>첨도</li>
      <li>공분산</li>
      <li>조건부확률</li>
    </ul>
  </li>
  <li><strong>몬테카를로 샘플링</strong>
    <ul>
      <li>데이터(샘플링)를 통해 기댓값을 계산하는 방법</li>
      <li>대수의 법칙을 통해 수렴성을 보장한다.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import numpy as np

def monte(fun, low, high, sample_size=100, repeat=10):
    int_len = np.abs(high - low)
    stat = []

    for _ in range(repeat):
        x = np.random.uniform(low=low, high=high, size=sample_size)
        fun_x = fun(x)
        int_val = int_len * np.mean(fun_x)
        stat.append(int_val)

    return np.mean(stat), np.std(stat)


- 주어진 함수
def f_x(x):
    return np.exp(-x**2)


print(monte(f_x, low=-1, high=1, sample_size=1000, repeat=100))

</code></pre></div></div>

<hr />
<h1 id="7-통계학">7. 통계학</h1>
<ul>
  <li>모수
    <ul>
      <li>통계적 모델링 : 확률분포를 추정하는 것.</li>
      <li>모수 추정
        <ul>
          <li>모수적 방법론
            <ul>
              <li>특정 확률 분포를 가정 후 모수를 추정하는 것.</li>
            </ul>
          </li>
          <li>비 모수적 방법론
            <ul>
              <li>가정 없이.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>데이터 관찰 -&gt; 확률 분포 가정
    <ul>
      <li>베르누이 분포</li>
      <li>카테고리 분포</li>
      <li>베타 분포</li>
      <li>감마분포, 로그정규분포</li>
      <li>정규분포, 라플라스분포</li>
    </ul>
  </li>
  <li>데이터 관찰 -&gt; 확률 분포 가정 -&gt; 평균, 분산 추정 -&gt; 모수 집단 추청</li>
  <li>중심극한정리
    <ul>
      <li>표뵨 평균의 표집분포는 N이 커질수록 정규분포를 따른다.</li>
    </ul>
  </li>
  <li>표집분포
    <ul>
      <li>통계량의 확률분포</li>
    </ul>
  </li>
  <li>최대가능도 추정법
    <ul>
      <li><strong>가장 가능성이 높은 모수를 추정하는 방법</strong></li>
      <li>x 에서 가장 높은 모수 집단 (가능도와 관점의 차이)</li>
      <li>기계학습에서 많이 쓰인다.</li>
      <li>가능도
        <ul>
          <li><strong>모수 쌔타 분포에서 데이터 x 를 발견할 가능성.</strong></li>
          <li>계산상 <code class="language-plaintext highlighter-rouge">로그가능도</code> 사용</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정규분포에서 최대 가능도 추정</li>
  <li>카테고리 분포에서 최대 가능도 추정</li>
  <li>딥러닝에서 최대가능도 추정법
    <ul>
      <li>소프트맥스 벡터 =&gt; 카테고리 분포</li>
      <li>두 개의 확률분포의 손실함부를 학습시키기
        <ul>
          <li>쿨백-라이블러 발산을 최소화</li>
          <li>분류 문제에서 정답레이블을 P, 모델 예측을 Q 라 두면 최대가능도 추정법은 쿨백-라이블러 발산을 최소화하는 것과 같음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>최대 우도법
    <ul>
      <li>데이터가 많이 모인 상황에서 <code class="language-plaintext highlighter-rouge">특정 데이터의 분포</code> 를 가정하고 <code class="language-plaintext highlighter-rouge">제일 가능성 높은</code> 모수를 추정하는 것.</li>
      <li>이 데이터들은 가장 그럴싸한 모수로부터 나왔을 것이다!</li>
      <li>정답 확률분포와 모델 추정 확률분포 손실함수 구해서 학습 시키는 방식으로 구하면 된다.</li>
      <li>확률과 가능도의 차이
        <ul>
          <li>확률 : 이 사건이 일어날 경우의 수를 전체 사건의 수로 나눈 것.</li>
          <li>가능도 : 지금 얻은 데이터가 이 분포에서 나왔을 가능도</li>
        </ul>
      </li>
      <li>가능도를 사용하는 이유는 우리는 모수를 알 수 없기 때문이다. 데이터로부터 실제 세계를 추정해야 한다. 그게 DL 이다.</li>
      <li>DL 에서 많이 쓰이니 잘 기억하자. 왜냐하면 가중치를 결정하는 데 도움을 주기 때문 ?</li>
      <li><a href="https://www.youtube.com/watch?v=XhlfVtGb19c">설명링크</a></li>
      <li><a href="https://angeloyeo.github.io/2020/07/17/MLE.html">설명블로그</a></li>
      <li>재요약
        <ul>
          <li>특정한 분포 $\theta$ 에서 관찰된 데이터 집합 x 의 가능도는 확률의 곱이라 할 수 있음.</li>
          <li>가능도 값이 최대가 되도록 하는 $\theta$ 를 찾자. 그것이 최대 우도법이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>쿨백-라이블러 발산
    <ul>
      <li><strong>쿨백-라이블러 발산(Kullback-Leibler divergence)</strong>은 두 확률분포 p(y), q(y) 의 분포모양이 얼마나 다른지를 숫자로 계산한 값</li>
      <li>그 값은 항상 양수이며 두 확률분포 완전히 같을 경우에만 0이 된다.</li>
      <li>교차엔트로피 개념</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="8-베이즈-통계학">8. 베이즈 통계학</h1>
<ul>
  <li>조건부 확률을 이용하면 정보를 갱신하는 방법을 알 수 있음.</li>
  <li>A 라는 사건이 추가로 주어졌을 때 B 가 일어날 확률은
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>B가 일어날 확률 * (P(A</td>
              <td>B) / P(A))</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>사후확률 = 사전확률 * 가능도/증거</li>
  <li>1종 오류, 2종 오류</li>
  <li>갱신된 사후확률을 계산 할 수 있다. (연속된 계산) (ex. 두번 검진)
    <ul>
      <li>정확도를 높일 수 있다.</li>
    </ul>
  </li>
  <li>조건부 확률을 토대로 인과관계를 함부로 추론해서는 안된다.
    <ul>
      <li>데이터에 따라 달라질 수 있기 때문임.</li>
      <li>중첩효과를 제거해서 가짜 연관관계를 제거해야 함.</li>
      <li>인과관계를 뒷받침하는 모델로서 작동하는 조건부확률</li>
    </ul>
  </li>
  <li>상관관계와 인과관계는 다르다.
    <ul>
      <li>키와 지능의 연관관계
        <ul>
          <li>상관관계 성림</li>
          <li>인과관계는 성립하지 않음.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>베이즈 추정법
    <ul>
      <li>베이즈 추정법(Bayesian estimation)은 모숫값이 가질 수 있는 모든 가능성의 분포를 계산하는 작업이다.</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="9-cnn">9. CNN</h1>
<ul>
  <li>이미지 연산에서 많이 사용하는 모델</li>
  <li>국소적 증폭, 국소적 증감</li>
  <li>여러 차원에서 적용 가능
    <ul>
      <li>채널이 여러개인 경우 커널의 채널 수와 입력의 채널수가 같아야 한다.</li>
    </ul>
  </li>
  <li>순전파
    <ul>
      <li>커널을 벡터상에서 움직여 함성함수를 적용.</li>
    </ul>
  </li>
  <li>역전파
    <ul>
      <li>Convolution 연산에서 어떻게 역전파를 적용할 것인가 ?</li>
      <li><a href="https://ratsgo.github.io/deep%20learning/2017/04/05/CNNbackprop/">참고자료</a></li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="10-rnn">10. RNN</h1>
<ul>
  <li>시퀀스데이터
    <ul>
      <li>연속적인 데이터</li>
      <li>발생 순서가 기록되어 있는 데이터</li>
      <li>독립 동등 분포를 위배한다.
        <ul>
          <li>데이터의 순서가 중요하다.</li>
          <li>과거의 데이터가 중요하다.</li>
          <li>하지만 모든 과거 데이터가 필요한 것은 아님 =&gt; 어텐션 모델 (<code class="language-plaintext highlighter-rouge">Attention all you need)</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>시퀀스데이터의 조건부확률</li>
  <li>시퀀스데이터는 과거의 길이를 사용해야 하는데 이것은 가변적인 데이터를 다뤄야 한다는 것을 의미한다.
    <ul>
      <li>하지만 이것을 타우라고 한다면 해결할 수 있다.</li>
    </ul>
  </li>
  <li>순전파</li>
  <li>역전파
    <ul>
      <li>BPTT(Backprogaion Throgh Time) 을 사용한다.
        <ul>
          <li>BPTT 미분은 매우 복잡하다. <a href="https://davi06000.tistory.com/92">링크</a></li>
          <li><a href="https://mmuratarat.github.io/2019-02-07/bptt-of-rnn">링크</a></li>
        </ul>
      </li>
      <li><strong>기울시 소실 문제 발생</strong> =&gt; 과거 데이터를 반영 못하는 문제 =&gt; 길이를 끊어서 나눠서 학습</li>
      <li>=&gt; LSTM, GRU 와 같은 고급 모델의 탄생</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="생각해-볼-문제">생각해 볼 문제</h1>
<ul>
  <li></li>
  <li></li>
</ul>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: ai tech - Day02</title><link href="http://localhost:4000/aitech/post-day02/" rel="alternate" type="text/html" title="Post: ai tech - Day02" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-08T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-day02</id><content type="html" xml:base="http://localhost:4000/aitech/post-day02/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: ai tech 1주차</title><link href="http://localhost:4000/aitech/post-1%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="Post: ai tech 1주차" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-09T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-1%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/aitech/post-1%EC%A3%BC%EC%B0%A8/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(23.3.6 ~ 23.3.12)
</code></pre></div></div>

<h1 id="1주차를-보내며">[1주차를 보내며]</h1>

<hr />
<h1 id="1주차">1주차</h1>
<ul>
  <li>강의
    <ul>
      <li>Python
        <ul>
          <li><a href="https://yunjinchoidev.github.io/aitech/post-python/">파이썬 강의록 정리</a></li>
        </ul>
      </li>
      <li>AIMath
        <ul>
          <li><a href="https://yunjinchoidev.github.io/aitech/post-aimath/">AIMath 강의록 정리</a></li>
        </ul>
      </li>
      <li>Pytorch
        <ul>
          <li><a href="https://yunjinchoidev.github.io/aitech/post-pytorch/">Pytorch 강의록 정리</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>회고</li>
</ul>

<hr />]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: ai tech - Day01</title><link href="http://localhost:4000/aitech/post-day01/" rel="alternate" type="text/html" title="Post: ai tech - Day01" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-09T07:20:02+09:00</updated><id>http://localhost:4000/aitech/post-day01</id><content type="html" xml:base="http://localhost:4000/aitech/post-day01/"><![CDATA[<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[boostcamp_AITech_5th]]></summary></entry><entry><title type="html">Post: ai tech 온보딩</title><link href="http://localhost:4000/aitech/post-%EC%98%A8%EB%B3%B4%EB%94%A9/" rel="alternate" type="text/html" title="Post: ai tech 온보딩" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-09T06:20:02+09:00</updated><id>http://localhost:4000/aitech/post-%EC%98%A8%EB%B3%B4%EB%94%A9</id><content type="html" xml:base="http://localhost:4000/aitech/post-%EC%98%A8%EB%B3%B4%EB%94%A9/"><![CDATA[<!-- ![image](https://user-images.githubusercontent.com/45550607/102208312-9b284180-3f12-11eb-8467-7b5ea1779ac7.png)
{: .align-center} -->

<h1 id="boostcamp_aitech_5th">boostcamp_AITech_5th</h1>
<p><img src="../../../image/aitech.png" alt="image" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(23.3.1 ~ 23.3.5)
</code></pre></div></div>

<h1 id="온보딩기간을-보내며">[온보딩기간을 보내며]</h1>
<p>3월 1일 부터 3월 5일까지 온보딩 기간을 보내며 설레는 마음으로 공부를 했다. 파이썬, ai math, pytorch 강의를 들었다. 수학과를 다니면서 선형대수학을 과연 사용할 일이 있을까 생각을 했었는데 딥러닝에서 매우 중요하다고 한다. 통계학도 중요하다. 그래서 선형대수, 수리통계 책을 구입했다.</p>

<p>8월 2일까지 진행한다. 나는 nlp 트랙으로 참여하게 되었는데 앞으로 해야 할 일이 많다. 하반기에 취업을 하던가 대학원을 갈 생각이다.</p>

<p>깃허브에 레포지토리를 하나 만들어 두었다. 깃허브 블로그를 만들었으니 레포지토리에 올리지 않고 이곳에 올리는 게 더 깔끔 할 것 같기도 하다.</p>]]></content><author><name>최윤진</name></author><category term="aitech" /><summary type="html"><![CDATA[]]></summary></entry></feed>